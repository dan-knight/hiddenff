from utility import team_keys, roof_keys, create_datetime, create_datefrom sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, Date, Boolean, ForeignKeyfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmaker, relationshipimport osimport datetime as dturi = os.getenv('DATABASE_URI')engine = create_engine(uri)Session = sessionmaker(bind=engine)session = Session()Base = declarative_base()class HiddenFF:    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)    modifiable_columns = frozenset()    total_columns = {}    total_iterable = ''    @classmethod    def replace(cls, data):        db_row = cls.get(data)        if not db_row:            db_row = cls.new(data)            session.add(db_row)        else:            db_row.update(data)        return db_row    @staticmethod    def new(data):        return None    @staticmethod    def get(data):        return None    def update(self, data):        for column in self.modifiable_columns:            self.__setattr__(column, data[column])    @classmethod    def sanitize_data(cls, data):        pass    def calculate_stats(self):        def get_totals():            totals = {}            column_name_pairs = self.total_columns.items()            try:                for i in self.__getattribute__(self.total_iterable):                    for index, (key, value) in enumerate(column_name_pairs):                        totals[key] = totals.get(key, 0) + i.__getattribute__(value)            except AttributeError:                pass            return totals        stats = get_totals()        stats.update(self.get_divided_stats())        def set_calculated_stats():            for index, (key, value) in enumerate(stats.items()):                self.__setattr__(key, value)        set_calculated_stats()    def get_divided_stats(self):        return {}class Game(HiddenFF, Base):    __tablename__ = 'games'    id = Column(Integer, primary_key=True)    week = Column(Integer, nullable=False)    start = Column(DateTime, nullable=False)    length = Column(Integer)    stadium = Column(String(255), nullable=False)    roof = Column(Boolean)    surface = Column(String(255))    total_points = Column(Integer)    total_snaps = Column(Integer)    team_games = relationship('TeamGame', back_populates='game')    modifiable_columns = frozenset(['start', 'length', 'stadium', 'roof', 'surface'])    total_columns = {'total_points': 'score',                     'total_snaps': 'snaps'}    total_iterable = 'team_games'    @staticmethod    def update_from_scraped(scraped_data):        Game.sanitize_data(scraped_data)        db_game = Game.replace(scraped_data)        def parse_spread():            split_text = scraped_data['spread'].rsplit(' ', 1)            return split_text[0], float(split_text[1])        favorite, spread = parse_spread()        over_under = float(scraped_data['over_under'].split(' ', 1)[0])        split_total = over_under / 2        def parse_team_games():            def parse_data(scraped_team_game):                team = team_keys[scraped_team_game['team']]                is_favorite = team == team_keys[favorite]                def get_handicap():                    return spread if is_favorite else spread * -1                handicap = get_handicap()                def get_total():                    return split_total - (handicap / 2)                team_game = {                    'team': team,                    'score': scraped_team_game['score'],                    'handicap': get_handicap(),                    'total': get_total(),                    'snaps': scraped_team_game['snaps'],                    'game_id': db_game.id,                    'week': db_game.week                }                return team_game            return [parse_data(game) for game in scraped_data['team_games']]        for team_game in parse_team_games():            db_team_game = TeamGame.replace(team_game)            def connect_team_game():                db_game.team_games.append(db_team_game)                db_team = Team.get_from_cache(team_game['team'])                db_team.team_games.append(db_team_game)            connect_team_game()    @staticmethod    def new(scraped_data):        return Game(week=scraped_data['week'],                    start=scraped_data['start'],                    length=scraped_data['length'],                    stadium=scraped_data['stadium'],                    roof=scraped_data['roof'],                    surface=scraped_data['surface'])    @staticmethod    def get(scraped_data):        game = session.query(Game).filter_by(stadium=scraped_data['stadium'],                                             start=scraped_data['start']).first()        return game    @classmethod    def sanitize_data(cls, data):        def parse_length():            split_text = data['length'].split(':')            timedelta = dt.timedelta(int(split_text[0]),                                     int(split_text[1]))            return timedelta.total_seconds()        data['start'] = create_datetime(data['start'])        data['length'] = parse_length()        data['roof'] = roof_keys[data['roof']]class Team(HiddenFF, Base):    __tablename__ = 'teams'    short = Column(String(3), primary_key=True)    city = Column(String(255), nullable=False)    mascot = Column(String(255), nullable=False)    total_rush_yd = Column(Integer)    total_rec_yd = Column(Integer)    total_pass_yd = Column(Integer)    players = relationship('Player', back_populates='team')    team_games = relationship('TeamGame', back_populates='team')    modifiable_columns = frozenset(['short', 'city', 'mascot'])    total_columns = {'total_rush_yd': 'rush_yd',                     'total_rec_yd': 'rec_yd',                     'total_pass_yd': 'pass_yd'}    total_iterable = 'team_games'    cache = {}    @staticmethod    def new(data):        team = Team(short=data['short'],                    city=data['city'],                    mascot=data['mascot'])        return team    @staticmethod    def get(data):        team = session.query(Team).filter_by(short=data['short']).first()        return team    @staticmethod    def get_from_cache(team_id):        try:            db_team = Team.cache[team_id]        except KeyError:            db_team = Team.get({'short': team_id})            Team.cache[team_id] = db_team        return db_teamclass Player(HiddenFF, Base):    __tablename__ = 'players'    id = Column(Integer, primary_key=True)    first = Column(String(32), nullable=False)    last = Column(String(32), nullable=False)    position = Column(String(2))    team_id = Column(String(3), ForeignKey('teams.short'))    birthday = Column(Date)    total_rush_yd = Column(Integer)    total_rec_yd = Column(Integer)    total_pass_yd = Column(Integer)    team = relationship('Team', back_populates='players')    player_games = relationship('PlayerGame', back_populates='player')    def __repr__(self):        return '%s %s (%s): %s' % (self.first, self.last, self.position, self.team)    modifiable_columns = frozenset(['position', 'team_id'])    total_columns = {'total_rush_yd': 'rush_yd',                     'total_rec_yd': 'rec_yd',                     'total_pass_yd': 'pass_yd'}    total_iterable = 'player_games'    @staticmethod    def update_from_scraped(scraped_data):        team_id = team_keys[scraped_data['team']]        scraped_data['team_id'] = team_id        db_player = Player.replace(scraped_data)        if team_id:            db_team = Team.get_from_cache(team_id)            db_team.players.append(db_player)        for game in scraped_data.get('games'):            def prepare_data():                game['player_id'] = db_player.id                PlayerGame.sanitize_data(game)            prepare_data()            db_player_game = PlayerGame.replace(game)            db_team_game = TeamGame.get({'team': game['team'],                                         'week': game['week']})            def connect_player_game():                db_player.player_games.append(db_player_game)                db_team_game.player_games.append(db_player_game)            connect_player_game()    @staticmethod    def new(data):        player = Player(first=data['first'],                        last=data['last'],                        position=data['position'],                        birthday=create_date(data['birthday']))        return player    @staticmethod    def get(data):        player = session.query(Player).filter_by(first=data['first'],                                                 last=data['last'],                                                 birthday=data['birthday']).first()        return playerclass TeamGame(HiddenFF, Base):    __tablename__ = 'team_games'    id = Column(Integer, primary_key=True)    game_id = Column(Integer, ForeignKey('games.id'))    team_id = Column(String(3), ForeignKey('teams.short'))    score = Column(Integer)    handicap = Column(Float)    total = Column(Float)    rush_yd = Column(Integer)    rec_yd = Column(Integer)    pass_yd = Column(Integer)    snaps = Column(Integer)    rush_plays = Column(Integer)    pass_plays = Column(Integer)    team = relationship('Team', back_populates='team_games')    game = relationship('Game', back_populates='team_games')    player_games = relationship('PlayerGame', back_populates='team_game')    modifiable_columns = frozenset(['score', 'handicap', 'total', 'snaps'])    total_columns = {'rush_yd': 'rush_yd',                     'rec_yd': 'rec_yd',                     'pass_yd': 'pass_yd',                     'rush_plays': 'rush_att',                     'pass_plays': 'pass_att'}    total_iterable = 'player_games'    @staticmethod    def new(data):        game = TeamGame(score=data['score'],                        handicap=data['handicap'],                        total=data['total'],                        snaps=data['snaps'])        return game    @staticmethod    def get(data):        game = session.query(TeamGame).join(TeamGame.team).filter_by(short=data['team']).\            join(TeamGame.game).filter_by(week=data['week']).first()        return game    def get_week(self):        return self.game.weekclass PlayerGame(HiddenFF, Base):    __tablename__ = 'player_games'    id = Column(Integer, primary_key=True)    player_id = Column(Integer, ForeignKey('players.id'))    team_game_id = Column(Integer, ForeignKey('team_games.id'))    rush_att = Column(Integer, nullable=False)    rush_yd = Column(Integer, nullable=False)    rush_yd_per_att = Column(Float)    rush_td = Column(Integer, nullable=False)    tgt = Column(Integer, nullable=False)    rec = Column(Integer, nullable=False)    rec_yd = Column(Integer, nullable=False)    rec_yd_per_tgt = Column(Float)    rec_yd_per_rec = Column(Float)    rec_td = Column(Integer, nullable=False)    pass_att = Column(Integer, nullable=False)    pass_cmp = Column(Integer, nullable=False)    pass_yd = Column(Integer, nullable=False)    pass_yd_per_att = Column(Float)    pass_yd_per_cmp = Column(Float)    pass_td = Column(Integer, nullable=False)    fum = Column(Integer, nullable=False)    int = Column(Integer, nullable=False)    sacked = Column(Integer, nullable=False)    snaps = Column(Integer, nullable=False)    snap_pct = Column(Float)    rush_play_pct = Column(Float)    pass_play_pct = Column(Float)    player = relationship('Player', back_populates='player_games')    team_game = relationship('TeamGame', back_populates='player_games')    modifiable_columns = frozenset([        'rush_att', 'rush_yd', 'rush_td', 'fum',        'tgt', 'rec', 'rec_yd', 'rec_td',        'pass_att', 'pass_cmp', 'pass_yd', 'pass_td',        'fum', 'int', 'sacked', 'snaps'    ])    @staticmethod    def new(data):        game = PlayerGame(rush_att=data['rush_att'],                          rush_yd=data['rush_yd'],                          rush_td=data['rush_td'],                          tgt=data['tgt'],                          rec=data['rec'],                          rec_yd=data['rec_yd'],                          rec_td=data['rec_td'],                          pass_att=data['pass_att'],                          pass_cmp=data['pass_cmp'],                          pass_yd=data['pass_yd'],                          pass_td=data['pass_td'],                          fum=data['fum'],                          int=data['int'],                          sacked=data['sacked'],                          snaps=data['snaps'])        return game    @staticmethod    def get(data):        game = session.query(PlayerGame).filter_by(player_id=data['player_id'])\            .join(PlayerGame.team_game)\            .join(TeamGame.game, aliased=True, from_joinpoint=True).filter_by(week=data['week']).first()        return game    @classmethod    def sanitize_data(cls, data):        data['team'] = team_keys[data['team']]        for column in cls.modifiable_columns:            value = data[column]            if not value:                value = 0            data[column] = value    def get_week(self):        return self.team_game.game.week    def get_team(self):        return self.team_game.team    def get_divided_stats(self):        column_data = self.get_divided_columns()        return {key: divide_stat(*column_data[key]) for key in column_data}    def get_divided_columns(self):        return {'rush_yd_per_att': (self.rush_yd, self.rush_att),                'rec_yd_per_tgt': (self.rec_yd, self.tgt),                'rec_yd_per_cmp': (self.rec_yd, self.rec),                'pass_yd_per_att': (self.pass_yd, self.pass_att),                'pass_yd_per_cmp': (self.pass_yd, self.pass_cmp),                'snap_pct': (self.snaps, self.team_game.snaps),                'rush_play_pct': (self.rush_att, self.team_game.rush_plays),                'pass_play_pct': (self.pass_att, self.team_game.pass_plays)}# Utilitiesdef reset_tables(tables=None):    if tables:        Base.metadata.drop_all(engine, tables=[table.__table__ for table in tables])    else:        Base.metadata.drop_all(engine)    Base.metadata.create_all(engine)def divide_stat(dividend, divisor):    percent = 0    if not divisor == 0:        percent = dividend / divisor    return percent