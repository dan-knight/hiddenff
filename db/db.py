from utility import team_keys, roof_keys, create_datetime, create_datefrom sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, Date, Boolean, ForeignKeyfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmaker, relationshipimport osimport datetime as dturi = os.getenv('DATABASE_URI')engine = create_engine(uri)Session = sessionmaker(bind=engine)session = Session()Base = declarative_base()class HiddenFF:    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)    @classmethod    def replace(cls, data):        db_row = cls.get(data)        if not db_row:            db_row = cls.new(data)            session.add(db_row)        else:            db_row.update(data)        return db_row    @staticmethod    def new(data):        return None    @staticmethod    def get(data):        return None    def update(self, data):        for column in self.get_modifiable_columns():            self.__setattr__(column, data[column])    @classmethod    def sanitize_data(cls, data):        pass    @staticmethod    def get_modifiable_columns():        return set()    def calculate_stats(self):        stats = {}        totals = self.get_total_stats({})        stats.update(totals['columns'])        stats.update(self.get_divided_stats(totals))        def set_calculated_stats():            for index, (key, value) in enumerate(stats.items()):                self.__setattr__(key, value)        set_calculated_stats()    def get_total_stats(self, data):        totals = {'columns': {},                  'stats': {}}        column_name_pairs = self.get_total_columns().items()        data_name_pairs = data.items()        try:            for i in self.get_total_iterable():                def add_to_total(key, value, total_dict):                    total_dict[key] = total_dict.get(key, 0) + i.__getattribute__(value)                for index, (k, v) in enumerate(column_name_pairs):                    add_to_total(k, v, totals['columns'])                for index, (k, v) in enumerate(data_name_pairs):                    add_to_total(k, v, totals['stats'])        except AttributeError:            pass        return totals    def get_divided_stats(self, data):        column_data = self.get_divided_columns(data)        return {key: divide_stat(*column_data[key]) for key in column_data}    def get_total_iterable(self):        return []    @staticmethod    def get_total_columns():        return {}    def get_divided_columns(self, data):        return {}class Game(HiddenFF, Base):    __tablename__ = 'games'    id = Column(Integer, primary_key=True)    week = Column(Integer, nullable=False)    start = Column(DateTime, nullable=False)    length = Column(Integer)    stadium = Column(String(255), nullable=False)    roof = Column(Boolean)    surface = Column(String(255))    total_points = Column(Integer)    total_snaps = Column(Integer)    team_games = relationship('TeamGame', back_populates='game')    @staticmethod    def update_from_scraped(scraped_data):        Game.sanitize_data(scraped_data)        db_game = Game.replace(scraped_data)        def parse_spread():            split_text = scraped_data['spread'].rsplit(' ', 1)            return split_text[0], float(split_text[1])        favorite, spread = parse_spread()        over_under = float(scraped_data['over_under'].split(' ', 1)[0])        split_total = over_under / 2        def parse_team_games():            def parse_data(scraped_team_game):                team = team_keys[scraped_team_game['team']]                is_favorite = team == team_keys[favorite]                def get_handicap():                    return spread if is_favorite else spread * -1                handicap = get_handicap()                def get_total():                    return split_total - (handicap / 2)                team_game = {                    'team': team,                    'score': scraped_team_game['score'],                    'handicap': get_handicap(),                    'total': get_total(),                    'snaps': scraped_team_game['snaps'],                    'game_id': db_game.id,                    'week': db_game.week                }                return team_game            return [parse_data(game) for game in scraped_data['team_games']]        for team_game in parse_team_games():            db_team_game = TeamGame.replace(team_game)            def connect_team_game():                db_game.team_games.append(db_team_game)                db_team = Team.get_from_cache(team_game['team'])                db_team.team_games.append(db_team_game)            connect_team_game()    @staticmethod    def new(scraped_data):        return Game(week=scraped_data['week'],                    start=scraped_data['start'],                    length=scraped_data['length'],                    stadium=scraped_data['stadium'],                    roof=scraped_data['roof'],                    surface=scraped_data['surface'])    @staticmethod    def get(scraped_data):        game = session.query(Game).filter_by(stadium=scraped_data['stadium'],                                             start=scraped_data['start']).first()        return game    @staticmethod    def get_modifiable_columns():        return {'start', 'length', 'stadium', 'roof', 'surface'}    @classmethod    def sanitize_data(cls, data):        def parse_length():            split_text = data['length'].split(':')            timedelta = dt.timedelta(int(split_text[0]),                                     int(split_text[1]))            return timedelta.total_seconds()        data['start'] = create_datetime(data['start'])        data['length'] = parse_length()        data['roof'] = roof_keys[data['roof']]    def get_total_iterable(self):        return self.team_games    @staticmethod    def get_total_columns():        return {'total_points': 'score',                'total_snaps': 'snaps'}class Team(HiddenFF, Base):    __tablename__ = 'teams'    short = Column(String(3), primary_key=True)    city = Column(String(255), nullable=False)    mascot = Column(String(255), nullable=False)    total_rush_yd = Column(Integer)    total_rec_yd = Column(Integer)    total_pass_yd = Column(Integer)    players = relationship('Player', back_populates='team')    team_games = relationship('TeamGame', back_populates='team')    cache = {}    @staticmethod    def new(data):        team = Team(short=data['short'],                    city=data['city'],                    mascot=data['mascot'])        return team    @staticmethod    def get(data):        team = session.query(Team).filter_by(short=data['short']).first()        return team    @staticmethod    def get_from_cache(team_id):        try:            db_team = Team.cache[team_id]        except KeyError:            db_team = Team.get({'short': team_id})            Team.cache[team_id] = db_team        return db_team    @staticmethod    def get_modifiable_columns():        return {'short', 'city', 'mascot'}    def get_total_iterable(self):        return self.team_games    @staticmethod    def get_total_columns():        return {'total_rush_yd': 'rush_yd',                'total_rec_yd': 'rec_yd',                'total_pass_yd': 'pass_yd'}class Player(HiddenFF, Base):    __tablename__ = 'players'    id = Column(Integer, primary_key=True)    first = Column(String(32), nullable=False)    last = Column(String(32), nullable=False)    position = Column(String(2))    team_id = Column(String(3), ForeignKey('teams.short'))    birthday = Column(Date)    total_rush_att = Column(Integer)    total_rush_yd = Column(Integer)    total_rush_td = Column(Integer)    avg_rush_yd_per_att = Column(Float)    total_rush_yd_per_att = Column(Float)    total_tgt = Column(Integer)    total_rec = Column(Integer)    total_rec_yd = Column(Integer)    total_rec_td = Column(Integer)    avg_rec_yd_per_tgt = Column(Float)    total_rec_yd_per_tgt = Column(Float)    avg_rec_yd_per_rec = Column(Float)    total_rec_yd_per_rec = Column(Float)    total_pass_att = Column(Integer)    total_pass_cmp = Column(Integer)    total_pass_yd = Column(Integer)    total_pass_td = Column(Integer)    avg_pass_yd_per_att = Column(Float)    total_pass_yd_per_att = Column(Float)    avg_pass_yd_per_cmp = Column(Float)    total_pass_yd_per_cmp = Column(Float)    total_fum = Column(Integer)    total_int = Column(Integer)    total_sacked = Column(Integer)    team = relationship('Team', back_populates='players')    player_games = relationship('PlayerGame', back_populates='player')    def __repr__(self):        return '%s %s (%s): %s' % (self.first, self.last, self.position, self.team)    @staticmethod    def update_from_scraped(scraped_data):        team_id = team_keys[scraped_data['team']]        scraped_data['team_id'] = team_id        db_player = Player.replace(scraped_data)        if team_id:            db_team = Team.get_from_cache(team_id)            db_team.players.append(db_player)        for game in scraped_data.get('games'):            def prepare_data():                game['player_id'] = db_player.id                PlayerGame.sanitize_data(game)            prepare_data()            db_player_game = PlayerGame.replace(game)            db_team_game = TeamGame.get({'team': game['team'],                                         'week': game['week']})            def connect_player_game():                db_player.player_games.append(db_player_game)                db_team_game.player_games.append(db_player_game)            connect_player_game()    @staticmethod    def new(data):        player = Player(first=data['first'],                        last=data['last'],                        position=data['position'],                        birthday=create_date(data['birthday']))        return player    @staticmethod    def get(data):        player = session.query(Player).filter_by(first=data['first'],                                                 last=data['last'],                                                 birthday=data['birthday']).first()        return player    @staticmethod    def get_modifiable_columns():        return {'position', 'team_id'}    def get_total_stats(self, data):        data_column_pairs = {'total_rush_yd_per_att': 'rush_yd_per_att',                             'total_rec_yd_per_tgt': 'rec_yd_per_tgt',                             'total_rec_yd_per_rec': 'rec_yd_per_rec',                             'total_pass_yd_per_att': 'pass_yd_per_att',                             'total_pass_yd_per_cmp': 'pass_yd_per_cmp'}        return super().get_total_stats(data_column_pairs)    def get_total_iterable(self):        return self.player_games    @staticmethod    def get_total_columns():        return {'total_rush_att': 'rush_att',                'total_rush_yd': 'rush_yd',                'total_rush_td': 'rush_td',                'total_tgt': 'tgt',                'total_rec': 'rec',                'total_rec_yd': 'rec_yd',                'total_rec_td': 'rec_td',                'total_pass_att': 'pass_att',                'total_pass_cmp': 'pass_cmp',                'total_pass_yd': 'pass_yd',                'total_pass_td': 'pass_td',                'total_fum': 'fum',                'total_int': 'int',                'total_sacked': 'sacked'}    def get_divided_columns(self, data):        games_played = len(self.player_games)        return {'avg_rush_yd_per_att': (data['stats']['total_rush_yd_per_att'], games_played),                'total_rush_yd_per_att': (data['columns']['total_rush_yd'], data['columns']['total_rush_att']),                'avg_rec_yd_per_tgt': (data['stats']['total_rec_yd_per_tgt'], games_played),                'total_rec_yd_per_tgt': (data['columns']['total_rec_yd'], data['columns']['total_rec']),                'avg_rec_yd_per_rec': (data['stats']['total_rec_yd_per_rec'], games_played),                'total_rec_yd_per_rec': (data['columns']['total_rec_yd'], data['columns']['total_rec']),                'avg_pass_yd_per_att': (data['stats']['total_pass_yd_per_att'], games_played),                'total_pass_yd_per_att': (data['columns']['total_pass_yd'], data['columns']['total_pass_att']),                'avg_pass_yd_per_cmp': (data['stats']['total_pass_yd_per_cmp'], games_played),                'total_pass_yd_per_cmp': (data['columns']['total_pass_yd'], data['columns']['total_pass_cmp'])}class TeamGame(HiddenFF, Base):    __tablename__ = 'team_games'    id = Column(Integer, primary_key=True)    game_id = Column(Integer, ForeignKey('games.id'))    team_id = Column(String(3), ForeignKey('teams.short'))    score = Column(Integer)    handicap = Column(Float)    total = Column(Float)    rush_yd = Column(Integer)    rec_yd = Column(Integer)    pass_yd = Column(Integer)    snaps = Column(Integer)    rush_plays = Column(Integer)    pass_plays = Column(Integer)    team = relationship('Team', back_populates='team_games')    game = relationship('Game', back_populates='team_games')    player_games = relationship('PlayerGame', back_populates='team_game')    @staticmethod    def new(data):        game = TeamGame(score=data['score'],                        handicap=data['handicap'],                        total=data['total'],                        snaps=data['snaps'])        return game    @staticmethod    def get(data):        game = session.query(TeamGame).join(TeamGame.team).filter_by(short=data['team']).\            join(TeamGame.game).filter_by(week=data['week']).first()        return game    @staticmethod    def get_modifiable_columns():        return {'score', 'handicap', 'total', 'snaps'}    def get_week(self):        return self.game.week    def get_total_iterable(self):        return self.player_games    @staticmethod    def get_total_columns():        return {'rush_yd': 'rush_yd',                'rec_yd': 'rec_yd',                'pass_yd': 'pass_yd',                'rush_plays': 'rush_att',                'pass_plays': 'pass_att'}class PlayerGame(HiddenFF, Base):    __tablename__ = 'player_games'    id = Column(Integer, primary_key=True)    player_id = Column(Integer, ForeignKey('players.id'))    team_game_id = Column(Integer, ForeignKey('team_games.id'))    rush_att = Column(Integer, nullable=False)    rush_yd = Column(Integer, nullable=False)    rush_yd_per_att = Column(Float)    rush_td = Column(Integer, nullable=False)    tgt = Column(Integer, nullable=False)    rec = Column(Integer, nullable=False)    rec_yd = Column(Integer, nullable=False)    rec_yd_per_tgt = Column(Float)    rec_yd_per_rec = Column(Float)    rec_td = Column(Integer, nullable=False)    pass_att = Column(Integer, nullable=False)    pass_cmp = Column(Integer, nullable=False)    pass_yd = Column(Integer, nullable=False)    pass_yd_per_att = Column(Float)    pass_yd_per_cmp = Column(Float)    pass_td = Column(Integer, nullable=False)    fum = Column(Integer, nullable=False)    int = Column(Integer, nullable=False)    sacked = Column(Integer, nullable=False)    snaps = Column(Integer, nullable=False)    snap_pct = Column(Float)    rush_play_pct = Column(Float)    pass_play_pct = Column(Float)    player = relationship('Player', back_populates='player_games')    team_game = relationship('TeamGame', back_populates='player_games')    @staticmethod    def new(data):        game = PlayerGame(rush_att=data['rush_att'],                          rush_yd=data['rush_yd'],                          rush_td=data['rush_td'],                          tgt=data['tgt'],                          rec=data['rec'],                          rec_yd=data['rec_yd'],                          rec_td=data['rec_td'],                          pass_att=data['pass_att'],                          pass_cmp=data['pass_cmp'],                          pass_yd=data['pass_yd'],                          pass_td=data['pass_td'],                          fum=data['fum'],                          int=data['int'],                          sacked=data['sacked'],                          snaps=data['snaps'])        return game    @staticmethod    def get(data):        game = session.query(PlayerGame).filter_by(player_id=data['player_id'])\            .join(PlayerGame.team_game)\            .join(TeamGame.game, aliased=True, from_joinpoint=True).filter_by(week=data['week']).first()        return game    @classmethod    def sanitize_data(cls, data):        data['team'] = team_keys[data['team']]        for column in cls.get_modifiable_columns():            value = data[column]            if not value:                value = 0            data[column] = value    @staticmethod    def get_modifiable_columns():        return {'rush_att', 'rush_yd', 'rush_td', 'fum',                'tgt', 'rec', 'rec_yd', 'rec_td',                'pass_att', 'pass_cmp', 'pass_yd', 'pass_td',                'fum', 'int', 'sacked', 'snaps'}    def get_week(self):        return self.team_game.game.week    def get_team(self):        return self.team_game.team    def get_divided_columns(self, data):        return {'rush_yd_per_att': (self.rush_yd, self.rush_att),                'rec_yd_per_tgt': (self.rec_yd, self.tgt),                'rec_yd_per_rec': (self.rec_yd, self.rec),                'pass_yd_per_att': (self.pass_yd, self.pass_att),                'pass_yd_per_cmp': (self.pass_yd, self.pass_cmp),                'snap_pct': (self.snaps, self.team_game.snaps),                'rush_play_pct': (self.rush_att, self.team_game.rush_plays),                'pass_play_pct': (self.pass_att, self.team_game.pass_plays)}def update_from_scraped(scraped_data):    teams = scraped_data.get('teams', [])    games = scraped_data.get('games', [])    players = scraped_data.get('players', [])    for team in teams:        Team.replace(team)    for game in games:        Game.update_from_scraped(game)    for player in players:        Player.update_from_scraped(player)    session.commit()def calculate_stats():    for game in session.query(Game).all():        game.calculate_stats()    for team_game in session.query(TeamGame).all():        team_game.calculate_stats()    for team in session.query(Team).all():        team.calculate_stats()    for player_game in session.query(PlayerGame).all():        player_game.calculate_stats()    for player in session.query(Player).all():        player.calculate_stats()    session.commit()# Utilitiesdef reset_tables(tables=None):    if tables:        Base.metadata.drop_all(engine, tables=[table.__table__ for table in tables])    else:        Base.metadata.drop_all(engine)    Base.metadata.create_all(engine)def divide_stat(dividend, divisor):    percent = 0    if not divisor == 0:        percent = dividend / divisor    return percentdef get_total(data):    total = 0    for i in data:        total += i    return total