from utility import team_keys, roof_keys, surface_keys, create_datetime, create_date, try_data_then_kwargsfrom config import current_yearfrom sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, Date, Boolean, ForeignKeyfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmaker, relationshipimport osimport datetime as dturi = os.getenv('DATABASE_URI')engine = create_engine(uri)Session = sessionmaker(bind=engine)session = Session()Base = declarative_base()class HiddenFF:    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)    cache = {}    @classmethod    def sanitize_data(cls, scraped_data):        return scraped_data.copy()    @classmethod    def replace(cls, sanitized_data):        db_row = cls.get(sanitized_data)        if not db_row:            db_row = cls.new(sanitized_data)            session.add(db_row)        else:            db_row.update(sanitized_data)        return db_row    @classmethod    def new(cls, sanitized_data, **kwargs):        row = cls()        row.set_attributes(sanitized_data, cls.get_initial_columns(), **kwargs)        return row    @staticmethod    def get_initial_columns():        return set()    def update(self, sanitized_data=None, **kwargs):        if sanitized_data is None:            sanitized_data = {}        data = {}        for column in self.get_modifiable_columns():            try:                value = try_data_then_kwargs(column, sanitized_data, **kwargs)                data.update({column: value})            except KeyError:                pass        self.set_attributes(data, data.keys())    @staticmethod    def get_modifiable_columns():        return set()    def set_attributes(self, sanitized_data, keys, **kwargs):        for key in keys:            value = try_data_then_kwargs(key, sanitized_data, **kwargs)            self.__setattr__(key, value)    @classmethod    def get(cls, sanitized_data=None, **kwargs):        if sanitized_data is None:            sanitized_data = {}        db_row = cls.get_from_cache(sanitized_data, **kwargs)        if not db_row:            db_row = cls.get_from_db(sanitized_data, **kwargs)        if db_row:            db_row.add_to_cache()        return db_row    @classmethod    def get_from_cache(cls, sanitized_data=None, **kwargs):        if sanitized_data is None:            sanitized_data = {}        try:            row_id = try_data_then_kwargs(cls.get_primary_key(), sanitized_data, **kwargs)            cached = cls.cache.get(row_id)        except KeyError:            cached = None        return cached    @classmethod    def get_from_db(cls, sanitized_data=None, **kwargs):        try:            row_id = try_data_then_kwargs(cls.get_primary_key(), sanitized_data, **kwargs)            row = cls.get_from_db_by_id(row_id)        except KeyError:            filters = {column: try_data_then_kwargs(column, sanitized_data, **kwargs)                       for column in cls.get_filter_columns()}            row = session.query(cls).filter_by(**filters).first()        return row    def add_to_cache(self):        self.cache.update({self.__getattribute__(self.get_primary_key()): self})    @classmethod    def get_from_db_by_id(cls, row_id):        row = session.query(cls).filter_by(**{cls.get_primary_key(): row_id}).first()        return row    @staticmethod    def get_primary_key():        return 'id'    @staticmethod    def get_filter_columns():        return set()    def calculate_stats(self):        stats = {}        totals = self.get_total_stats({})        stats.update(totals['columns'])        stats.update(self.get_divided_stats(totals))        def set_calculated_stats():            for index, (key, value) in enumerate(stats.items()):                self.__setattr__(key, value)        set_calculated_stats()    def get_total_stats(self, data):        totals = {'columns': {},                  'stats': {}}        column_name_pairs = self.get_total_columns().items()        data_name_pairs = data.items()        try:            for i in self.get_total_iterable():                def add_to_total(key, value, total_dict):                    total_dict[key] = total_dict.get(key, 0) + i.__getattribute__(value)                for index, (k, v) in enumerate(column_name_pairs):                    add_to_total(k, v, totals['columns'])                for index, (k, v) in enumerate(data_name_pairs):                    add_to_total(k, v, totals['stats'])        except AttributeError:            pass        return totals    def get_divided_stats(self, data):        column_data = self.get_divided_columns(data)        return {key: divide_stat(*column_data[key]) for key in column_data}    def get_total_iterable(self):        return []    @staticmethod    def get_total_columns():        return {}    def get_divided_columns(self, data):        return {}class Game(HiddenFF, Base):    __tablename__ = 'games'    id = Column(Integer, primary_key=True)    week = Column(Integer, nullable=False)    start = Column(DateTime, nullable=False)    length = Column(Integer)    stadium_id = Column(Integer, ForeignKey('stadiums.id'), nullable=False)    roof = Column(Boolean)    total_points = Column(Integer)    total_snaps = Column(Integer)    team_games = relationship('TeamGame', back_populates='game')    cache = {}    @classmethod    def sanitize_data(cls, scraped_data, **kwargs):        def parse_length():            split_text = scraped_data['length'].split(':')            timedelta = dt.timedelta(int(split_text[0]),                                     int(split_text[1]))            return timedelta.total_seconds()        def get_stadium_id():            name = try_data_then_kwargs('stadium_name', scraped_data, **kwargs)            return Stadium.get(name=name).id        return {'week': scraped_data['week'],                'start': create_datetime(scraped_data['start']),                'length': parse_length(),                'stadium_id': get_stadium_id(),                'roof': roof_keys[scraped_data['roof']]                }    @staticmethod    def get_initial_columns():        return {'week', 'start', 'length',                'stadium_id', 'roof'}    @staticmethod    def get_filter_columns():        return {'stadium_id', 'start'}    @staticmethod    def get_modifiable_columns():        return {'start', 'length', 'stadium_id', 'roof', 'surface'}    def get_total_iterable(self):        return self.team_games    @staticmethod    def get_total_columns():        return {'total_points': 'score',                'total_snaps': 'snaps'}    @staticmethod    def parse_over_under(over_under_text):        over_under = over_under_text.split(' ', 1)[0]        return float(over_under)class Stadium(HiddenFF, Base):    __tablename__ = 'stadiums'    id = Column(Integer, primary_key=True)    name = Column(String(255), nullable=False)    surface = Column(String(255), nullable=False)    teams = relationship('Team', back_populates='stadium')    cache = {}    # def get_team(self):    #     return [team.short for team in self.teams]    @classmethod    def sanitize_data(cls, scraped_data):        def convert_years(year_pair):            try:                years = [int(year) for year in year_pair.copy()]            except ValueError:                def check_year(year_text):                    text = year_text                    if year_text.casefold() == 'present':                        text = current_year                    return text                years = [int(check_year(year_text)) for year_text in year_pair.copy()]            return years        def get_range(year_pair):            years = convert_years(year_pair)            start = 0            end = 0            try:                start = years[0]                end = years[1]                if start > end:                    start = years[1]                    end = years[0]            except IndexError:                start = years[0]                end = start            return start, end + 1        def get_value_from_range(stat_name, year=current_year):            value = ''            for entry in scraped_data[stat_name]:                if year in range(*get_range(entry['seasons'])):                    value = entry[stat_name[:-1]]                    break            return value        def get_values_from_range(stat_name, year=current_year):            values = []            for entry in scraped_data[stat_name]:                if year in range(*get_range(entry['seasons'])):                    values.append(entry[stat_name[:-1]])            return values        return {'surface': surface_keys[get_value_from_range('surfaces')],                'name': get_value_from_range('names'),                'teams': [team_keys[team] for team in get_values_from_range('teams')]}    @classmethod    def new(cls, sanitized_data, **kwargs):        stadium = super().new(sanitized_data, **kwargs)        stadium.connect_teams(sanitized_data, **kwargs)        return stadium    def connect_teams(self, sanitized_data, **kwargs):        teams = try_data_then_kwargs('teams', sanitized_data, **kwargs)        for team in teams:            db_team = Team.get(short=team)            self.teams.append(db_team)    @staticmethod    def get_primary_key():        return 'id'    @staticmethod    def get_initial_columns():        return {'name', 'surface'}    @staticmethod    def get_filter_columns():        return {'name'}class Team(HiddenFF, Base):    __tablename__ = 'teams'    short = Column(String(3), primary_key=True)    city = Column(String(255), nullable=False)    mascot = Column(String(255), nullable=False)    stadium_id = Column(Integer, ForeignKey('stadiums.id'))    total_rush_yd = Column(Integer)    total_rec_yd = Column(Integer)    total_pass_yd = Column(Integer)    players = relationship('Player', back_populates='team')    team_games = relationship('TeamGame', back_populates='team')    stadium = relationship('Stadium', back_populates='teams')    cache = {}    @staticmethod    def get_primary_key():        return 'short'    @staticmethod    def get_initial_columns():        return {'short', 'city', 'mascot'}    @staticmethod    def get_filter_columns():        return {'short'}    @staticmethod    def get_modifiable_columns():        return {'short', 'city', 'mascot'}    def get_total_iterable(self):        return self.team_games    @staticmethod    def get_total_columns():        return {'total_rush_yd': 'rush_yd',                'total_rec_yd': 'rec_yd',                'total_pass_yd': 'pass_yd'}class Player(HiddenFF, Base):    __tablename__ = 'players'    id = Column(Integer, primary_key=True)    first = Column(String(32), nullable=False)    last = Column(String(32), nullable=False)    position = Column(String(2))    team_id = Column(String(3), ForeignKey('teams.short'))    birthday = Column(Date)    total_rush_att = Column(Integer)    total_rush_yd = Column(Integer)    total_rush_td = Column(Integer)    avg_rush_yd_per_att = Column(Float)    total_rush_yd_per_att = Column(Float)    total_tgt = Column(Integer)    total_rec = Column(Integer)    total_rec_yd = Column(Integer)    total_rec_td = Column(Integer)    avg_rec_yd_per_tgt = Column(Float)    total_rec_yd_per_tgt = Column(Float)    avg_rec_yd_per_rec = Column(Float)    total_rec_yd_per_rec = Column(Float)    total_pass_att = Column(Integer)    total_pass_cmp = Column(Integer)    total_pass_yd = Column(Integer)    total_pass_td = Column(Integer)    avg_pass_yd_per_att = Column(Float)    total_pass_yd_per_att = Column(Float)    avg_pass_yd_per_cmp = Column(Float)    total_pass_yd_per_cmp = Column(Float)    total_fum = Column(Integer)    total_int = Column(Integer)    total_sacked = Column(Integer)    team = relationship('Team', back_populates='players')    player_games = relationship('PlayerGame', back_populates='player')    cache = {}    def __repr__(self):        return '%s %s (%s): %s' % (self.first, self.last, self.position, self.team)    @classmethod    def sanitize_data(cls, scraped_data):        team = team_keys.get(scraped_data['team'])        return {'first': scraped_data['first'],                'last': scraped_data['last'],                'position': scraped_data['position'],                'team_id': team,                'birthday': scraped_data['birthday']         }    @staticmethod    def get_initial_columns():        return {'first', 'last', 'position', 'birthday', 'team_id'}    @staticmethod    def get_filter_columns():        return {'first', 'last', 'birthday'}    @staticmethod    def get_modifiable_columns():        return {'position', 'team_id'}    def get_total_stats(self, data):        data_column_pairs = {'total_rush_yd_per_att': 'rush_yd_per_att',                             'total_rec_yd_per_tgt': 'rec_yd_per_tgt',                             'total_rec_yd_per_rec': 'rec_yd_per_rec',                             'total_pass_yd_per_att': 'pass_yd_per_att',                             'total_pass_yd_per_cmp': 'pass_yd_per_cmp'}        return super().get_total_stats(data_column_pairs)    def get_total_iterable(self):        return self.player_games    @staticmethod    def get_total_columns():        return {'total_rush_att': 'rush_att',                'total_rush_yd': 'rush_yd',                'total_rush_td': 'rush_td',                'total_tgt': 'tgt',                'total_rec': 'rec',                'total_rec_yd': 'rec_yd',                'total_rec_td': 'rec_td',                'total_pass_att': 'pass_att',                'total_pass_cmp': 'pass_cmp',                'total_pass_yd': 'pass_yd',                'total_pass_td': 'pass_td',                'total_fum': 'fum',                'total_int': 'int',                'total_sacked': 'sacked'}    def get_divided_columns(self, data):        games_played = len(self.player_games)        return {'avg_rush_yd_per_att': (data['stats']['total_rush_yd_per_att'], games_played),                'total_rush_yd_per_att': (data['columns']['total_rush_yd'], data['columns']['total_rush_att']),                'avg_rec_yd_per_tgt': (data['stats']['total_rec_yd_per_tgt'], games_played),                'total_rec_yd_per_tgt': (data['columns']['total_rec_yd'], data['columns']['total_rec']),                'avg_rec_yd_per_rec': (data['stats']['total_rec_yd_per_rec'], games_played),                'total_rec_yd_per_rec': (data['columns']['total_rec_yd'], data['columns']['total_rec']),                'avg_pass_yd_per_att': (data['stats']['total_pass_yd_per_att'], games_played),                'total_pass_yd_per_att': (data['columns']['total_pass_yd'], data['columns']['total_pass_att']),                'avg_pass_yd_per_cmp': (data['stats']['total_pass_yd_per_cmp'], games_played),                'total_pass_yd_per_cmp': (data['columns']['total_pass_yd'], data['columns']['total_pass_cmp'])}class TeamGame(HiddenFF, Base):    __tablename__ = 'team_games'    id = Column(Integer, primary_key=True)    game_id = Column(Integer, ForeignKey('games.id'))    team_id = Column(String(3), ForeignKey('teams.short'))    score = Column(Integer)    vegas_handicap = Column(Float)    vegas_total = Column(Float)    rush_yd = Column(Integer)    rec_yd = Column(Integer)    pass_yd = Column(Integer)    snaps = Column(Integer)    rush_plays = Column(Integer)    pass_plays = Column(Integer)    team = relationship('Team', back_populates='team_games')    game = relationship('Game', back_populates='team_games')    player_games = relationship('PlayerGame', back_populates='team_game')    cache = {}    @staticmethod    def get(sanitized_data=None, **kwargs):        if sanitized_data is None:            sanitized_data = {}        game = session.query(TeamGame).join(TeamGame.team).\            filter_by(short=try_data_then_kwargs('team', sanitized_data, **kwargs)).\            join(TeamGame.game).filter_by(week=kwargs['week']).first()        return game    @classmethod    def sanitize_data(cls, scraped_data, **kwargs):        team = team_keys[scraped_data['team']]        def get_vegas_handicap():            try:                team_handicap = kwargs['vegas_handicap']            except KeyError:                team_handicap = TeamGame.parse_vegas_spread(kwargs['spread_text'], team)            return team_handicap        vegas_handicap = get_vegas_handicap()        def get_vegas_total():            try:                total = kwargs['vegas_total']            except KeyError:                total = TeamGame.parse_vegas_total(kwargs['over_under'], vegas_handicap)            return total        vegas_total = get_vegas_total()        def get_game_id():            try:                game = kwargs['game_id']            except KeyError:                game = Game.get({'start': kwargs['start'],                                 'stadium': kwargs['stadium']}).id            return game        game_id = get_game_id()        return {'game_id': game_id,                'team_id': team,                'vegas_handicap': vegas_handicap,                'vegas_total': vegas_total}    @staticmethod    def get_initial_columns():        return {'game_id', 'team_id', 'score',                'vegas_handicap', 'vegas_total',                'snaps'}    @staticmethod    def get_modifiable_columns():        return {'score', 'handicap', 'total', 'snaps'}    def get_week(self):        return self.game.week    def get_total_iterable(self):        return self.player_games    @staticmethod    def get_total_columns():        return {'rush_yd': 'rush_yd',                'rec_yd': 'rec_yd',                'pass_yd': 'pass_yd',                'rush_plays': 'rush_att',                'pass_plays': 'pass_att'}    @staticmethod    def parse_vegas_spread(spread_text, team_short):        def split_spread():            split_text = spread_text.rsplit(' ', 1)            return split_text[0], float(split_text[1])        favorite, spread = split_spread()        return spread if team_short == team_keys[favorite] else spread * -1    @staticmethod    def parse_vegas_total(over_under, handicap):        if type(over_under) == str:            over_under = Game.parse_over_under(over_under)        return (over_under / 2.0) - (handicap / 2.0)class PlayerGame(HiddenFF, Base):    __tablename__ = 'player_games'    id = Column(Integer, primary_key=True)    player_id = Column(Integer, ForeignKey('players.id'))    team_game_id = Column(Integer, ForeignKey('team_games.id'))    rush_att = Column(Integer, nullable=False)    rush_yd = Column(Integer, nullable=False)    rush_yd_per_att = Column(Float)    rush_td = Column(Integer, nullable=False)    tgt = Column(Integer, nullable=False)    rec = Column(Integer, nullable=False)    rec_yd = Column(Integer, nullable=False)    rec_yd_per_tgt = Column(Float)    rec_yd_per_rec = Column(Float)    rec_td = Column(Integer, nullable=False)    pass_att = Column(Integer, nullable=False)    pass_cmp = Column(Integer, nullable=False)    pass_yd = Column(Integer, nullable=False)    pass_yd_per_att = Column(Float)    pass_yd_per_cmp = Column(Float)    pass_td = Column(Integer, nullable=False)    fum = Column(Integer, nullable=False)    int = Column(Integer, nullable=False)    sacked = Column(Integer, nullable=False)    snaps = Column(Integer, nullable=False)    snap_pct = Column(Float)    rush_play_pct = Column(Float)    pass_play_pct = Column(Float)    player = relationship('Player', back_populates='player_games')    team_game = relationship('TeamGame', back_populates='player_games')    cache = {}    @staticmethod    def get(sanitized_data=None, **kwargs):        if sanitized_data is None:            sanitized_data = {}        try:            player_id = kwargs['player_id']        except KeyError:            player_id = Player.get(first=kwargs['first'],                                   last=kwargs['last'],                                   birthday=kwargs['birthday'])        game = session.query(PlayerGame).filter_by(player_id=player_id)\            .join(PlayerGame.team_game)\            .join(TeamGame.game, aliased=True, from_joinpoint=True)\            .filter_by(week=try_data_then_kwargs('week', sanitized_data, **kwargs)).first()        return game    @classmethod    def sanitize_data(cls, scraped_data):        scraped_data['team'] = team_keys[scraped_data['team']]        for column in cls.get_modifiable_columns():            value = scraped_data[column]            if not value:                value = 0            scraped_data[column] = value    @staticmethod    def get_initial_columns():        return {'player_id', 'team_game_id',                'rush_att', 'rush_yd', 'rush_td',                'tgt', 'rec', 'rec_yd', 'rec_td',                'pass_att', 'pass_cmp', 'pass_yd', 'pass_td',                'int', 'fum', 'sacked', 'snaps'}    @staticmethod    def get_modifiable_columns():        return {'rush_att', 'rush_yd', 'rush_td', 'fum',                'tgt', 'rec', 'rec_yd', 'rec_td',                'pass_att', 'pass_cmp', 'pass_yd', 'pass_td',                'fum', 'int', 'sacked', 'snaps'}    def get_week(self):        return self.team_game.game.week    def get_team(self):        return self.team_game.team    def get_divided_columns(self, data):        return {'rush_yd_per_att': (self.rush_yd, self.rush_att),                'rec_yd_per_tgt': (self.rec_yd, self.tgt),                'rec_yd_per_rec': (self.rec_yd, self.rec),                'pass_yd_per_att': (self.pass_yd, self.pass_att),                'pass_yd_per_cmp': (self.pass_yd, self.pass_cmp),                'snap_pct': (self.snaps, self.team_game.snaps),                'rush_play_pct': (self.rush_att, self.team_game.rush_plays),                'pass_play_pct': (self.pass_att, self.team_game.pass_plays)}def update_from_scraped(scraped_data):    teams = scraped_data.get('teams', [])    games = scraped_data.get('games', [])    players = scraped_data.get('players', [])    stadiums = scraped_data.get('stadiums', [])    for team in teams:        Team.replace(team)    for game in games:        Game.update_from_scraped(game)    for player in players:        Player.update_from_scraped(player)    for stadium in stadiums:        Stadium.update_from_scraped(stadium)    session.commit()def calculate_stats():    for game in session.query(Game).all():        game.calculate_stats()    for team_game in session.query(TeamGame).all():        team_game.calculate_stats()    for team in session.query(Team).all():        team.calculate_stats()    for player_game in session.query(PlayerGame).all():        player_game.calculate_stats()    for player in session.query(Player).all():        player.calculate_stats()    session.commit()# Utilitiesdef reset_tables(tables=None):    if tables:        Base.metadata.drop_all(engine, tables=[table.__table__ for table in tables])    else:        Base.metadata.drop_all(engine)    Base.metadata.create_all(engine)def divide_stat(dividend, divisor):    percent = 0    if not divisor == 0:        percent = dividend / divisor    return percentdef get_total(data):    total = 0    for i in data:        total += i    return total